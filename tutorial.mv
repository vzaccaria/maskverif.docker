(* This is a comment *)
(* ISW and
   (a0, a1) is a sharing of a secret a = a0 + a1
   (b0, b1) is a sharing of a secret b = b0 + b1
   return (c0,c1) a sharing of a secret c = a * b 
   c = (a0 + a1) * (b0 + b1) = 
     = a0b0 + a1b1 + a0b1 + a1b0
   IWS multiplication is done as follow

   c0 = a0b0 + r0
   c1 = a1b1 + ((r0 + a0b1) + a1b0) 
*)

proc ISW_AND:
  (* The algorithm takes two inputs each split in two shares *)
  inputs: a[0:1], b[0:1]
  (* It return one input split in two shares *)
  outputs: c[0:1]
  (* r is a fresh random local to the algorithm *)
  randoms: r;

  c[0] := a[0] * b[0];
  a0b1 := a[0] * b[1];
  a1b0 := a[1] * b[0];
  c[1] := a[1] * b[1];
  aux  := r + a0b1;      (* r + a0*b1)            *)
  aux  := aux + a1b0;    (* (r0 + a0*b1) + a1*b0) *) 
  c[0] := c[0] + r;
  c[1] := c[1] + aux;
end

(* Set the verbosity level *)
verbose 1

(* Check probing security without glitches *)
noglitch Probing ISW_AND 

(* To check with glitch, remove the "noglitch option" *)
Probing ISW_AND 

(* By default the verification order is the number of shares 
   of the input minus 1.
   You can force the order using the order option *)
noglitch order 2 Probing ISW_AND

(* You can also test the NI or SNI properties *)
noglitch NI ISW_AND
noglitch SNI ISW_AND
(* With glitch *)
NI ISW_AND
SNI ISW_AND

(* And change the order *)
order 2 noglitch NI ISW_AND

(* Finally for large verification you can use parallel verification
   (i.e. the verification is split into different processes) 
   Using the "para" option *)

para noglitch NI ISW_AND

(* The language allows to define function calls,
   So once ISW_AND is defined you can use it to define other functions.
*)

proc xor:
  inputs: a[0:1], b[0:1]
  outputs: c[0:1];

  c := a + b; 
    (* This is a short cut for c[0] := a[0] + b[0];
                               c[1] := a[1] + b[1];
    *)
end

(* A not very interesting function *)
proc test:
  inputs: a[0:1]
  outputs: c[0:1]
  shares: b[0:1];

  b = xor(a,a);
  c = ISW_AND(b, a);
end

(* You can print the program *)
print xor

print test

noglitch Probing test

(* You can stop the propagation of glitches using 
    the instruction x = ![ e ], play the role of a register *)

proc ISW_AND_NI_G:
  (* The algorithm takes two inputs each split in two shares *)
  inputs: a[0:1], b[0:1]
  (* It return one input split in two shares *)
  outputs: c[0:1]
  (* r is a fresh random local to the algorithm *)
  randoms: r;

  c[0] := a[0] * b[0];
  a0b1 := a[0] * b[1];
  a1b0 := a[1] * b[0];
  c[1] := a[1] * b[1];
  aux  = ![r + a0b1];      (* r + a0*b1)            *)
  aux  = ![aux + a1b0];    (* (r0 + a0*b1) + a1*b0) *) 
  c[0] := c[0] + r;
  c[1] := c[1] + aux;
end

Probing ISW_AND_NI_G
NI ISW_AND_NI_G
SNI ISW_AND_NI_G


proc ISW_AND_SNI_G:
  (* The algorithm takes two inputs each split in two shares *)
  inputs: a[0:1], b[0:1]
  (* It return one input split in two shares *)
  outputs: c[0:1]
  (* r is a fresh random local to the algorithm *)
  randoms: r;

  c[0] := a[0] * b[0];
  a0b1 := a[0] * b[1];
  a1b0 := a[1] * b[0];
  c[1] := a[1] * b[1];
  aux  = ![r + a0b1];      (* r + a0*b1)            *)
  aux  = ![aux + a1b0];    (* (r0 + a0*b1) + a1*b0) *) 
  c[0] = ![c[0] + r];
  c[1] = ![c[1] + aux];
end

SNI ISW_AND_SNI_G


proc DOM_AND:
  inputs: a[0:1], b[0:1]
  (* It return one input split in two shares *)
  outputs: c[0:1]
  (* r is a fresh random local to the algorithm *)
  randoms: r;

  a0b0 := a[0] * b[0];
  a0b1 := a[0] * b[1];
  a1b0 := a[1] * b[0];
  a1b1 := a[1] * b[1];
  aux0 = ![r + a0b1]; 
  aux1 = ![r + a1b0];      
  c[0] := a0b0 + aux0;
  c[1] := a1b1 + aux1;
end 

Probing DOM_AND
NI DOM_AND
SNI DOM_AND

proc DOM_AND_SNI:
  inputs: a[0:1], b[0:1]
  (* It return one input split in two shares *)
  outputs: c[0:1]
  (* r is a fresh random local to the algorithm *)
  randoms: r;

  a0b0 := a[0] * b[0];
  a0b1 := a[0] * b[1];
  a1b0 := a[1] * b[0];
  a1b1 := a[1] * b[1];
  aux0 = ![r + a0b1]; 
  aux1 = ![r + a1b0];      
  c[0] = ![a0b0 + aux0];
  c[1] = ![a1b1 + aux1];
end 

SNI DOM_AND_SNI


(* You can also load maskverif files *) 
(* read_file myfile.mv *)

(* Or ilang file, that can be generated by yosis *)
(* read_ilang myfile.ilang *)
